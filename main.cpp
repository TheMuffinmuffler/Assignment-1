#include <iostream>

#include <Eigen/Dense>
using namespace std;

#include <Eigen/Dense>
#include <cmath>
// imports equation lib for use such as Eigen to make matrix and ionstream for using std prints
//1.a
// generated by using chatgpt. It comes from the formula (3.30) Page 75 MR pre-print 2019
// Task 1a: Skew-symmetric matrix
// It makes a 3x3 matrix as shown by 3.30 x= [x1 x2 x3]T âˆˆR3
// Eigen is used to make a matrix with 3 dimentions (3x3)
Eigen::Matrix3d skew_symmetric(const Eigen::Vector3d& vec) {
    Eigen::Matrix3d skew;
    skew <<
                0,      -vec.z(),  vec.y(),
             vec.z(),      0,     -vec.x(),
            -vec.y(),  vec.x(),      0;
    return skew; //returns output
}

    //1.b Using the provided code to test the skew matrix
void skew_symmetric_test()
{
    Eigen::Matrix3d skew_matrix = skew_symmetric(Eigen::Vector3d{0.5, 0.5, 0.707107});
        cout << "Skew-symmetric matrix: " << endl; //prints out the text
        cout << skew_matrix << endl; // prints out the skew matrix from line 26.
        cout << "Skew-symmetric matrix transposition: " << endl;
        cout << -skew_matrix.transpose() << endl;
}
//2.a
//Builds rotation matrix with &x, &y og &z
//generated by chatgpt. Using equation (3.16) R= [Ë†xb Ë†yb Ë†zb] Page 65 MR pre-print 2019
Eigen::Matrix3d rotation_matrix_from_frame_axes(
    const Eigen::Vector3d &x,
    const Eigen::Vector3d &y,
    const Eigen::Vector3d &z)
{
    //rotation matrix
    Eigen::Matrix3d matrix;
    matrix.col(0) = x;
    matrix.col(1) = y;
    matrix.col(2) = z;
    return matrix;
}

//Task 2.b
// Rotation matrix about x-axis by "degrees"
//generated by chatgpt using R=Rot(xhat,Î¸), R=Rot(yhat,Î¸), R=Rot(zhat,Î¸)  Page 72 MR pre-print 2019
Eigen::Matrix3d rotate_x(double degrees)
{
    // Convert to radians using b.4 from Assignment 1 text.
    double radians = degrees * 0.0174532925;

    Eigen::Matrix3d matrix;
    matrix << 1,          0,           0,
              0, cos(radians), -sin(radians),
              0, sin(radians),  cos(radians);
    return matrix;
}
//task 2.c
// Rotation matrix about y-axis by "degrees"
//generated by chatgpt
Eigen::Matrix3d rotate_y(double degrees)
{
    // Convert degrees â†’ radians
    double radians = degrees * 0.0174532925;

    Eigen::Matrix3d matrix;
    matrix <<  cos(radians), 0, sin(radians),
               0,               1, 0,
              -sin(radians), 0, cos(radians);
    return matrix;
}
//Task 2.d
// Rotation matrix about z-axis by "degrees"
//generated by chatgpt
Eigen::Matrix3d rotate_z(double degrees)
{
    // Convert degrees â†’ radians
    double radians  = degrees * 0.0174532925;

    Eigen::Matrix3d matrix;
    matrix << cos(radians), -sin(radians), 0,
              sin(radians),  cos(radians), 0,
              0,                0,               1;
    return matrix;
}
//Task 2.e
// Skew-symmetric matrix helper
// generated by chatgpt using equation (3.51) Rot(Ë† Ï‰,Î¸) = e[Ë† Ï‰] Î¸= I+ sin Î¸[Ë† Ï‰] + (1âˆ’cos Î¸)[Ë† Ï‰]2 âˆˆSO(3)
//Page 82 MR pre-print 2019
// Rotation matrix from axis-angle (degrees)
Eigen::Matrix3d rotation_matrix_from_axis_angle(const Eigen::Vector3d &axis, double degrees)
{
    // Convert to radians
    double radians = degrees * 0.0174532925;

    // Normalize axis to ensure unit vector
    Eigen::Vector3d w = axis.normalized();

    // Build skew-symmetric matrix
    Eigen::Matrix3d w_hat = skew_symmetric(w);

    // Rodrigues' formula
    Eigen::Matrix3d R = Eigen::Matrix3d::Identity()
                        + sin(radians) * w_hat
                        + (1 - cos(radians)) * (w_hat * w_hat);

    return R;
}
// Task 2.f
//generated by chatgpt using Equation R(âº,Î²,ð›„) = I * Rot(zÌ‚,âº) * Rot(yÌ‚,Î²) * Rot(xÌ‚,ð›„) page 577 MR pre-print 2019
// found by help from Alexander RÃ¸der
// Euler ZYX rotation matrix
// e = (alpha, beta, gamma) in degrees
Eigen::Matrix3d rotation_matrix_from_euler_zyx(const Eigen::Vector3d &e)
{
    double alpha = e(0); // yaw (z)
    double beta  = e(1); // pitch (y)
    double gamma = e(2); // roll (x)

    // Use previously defined functions
    Eigen::Matrix3d Rz = rotate_z(alpha);
    Eigen::Matrix3d Ry = rotate_y(beta);
    Eigen::Matrix3d Rx = rotate_x(gamma);

    // Apply in ZYX order
    Eigen::Matrix3d R = Rz * Ry * Rx;

    return R;
}
//Task 2.g copy test from task description
void rotation_matrix_test()
{
    Eigen::Matrix3d rot = rotation_matrix_from_euler_zyx(Eigen::Vector3d{45.0, -45.0, 90.0});
    Eigen::Matrix3d rot_aa = rotation_matrix_from_axis_angle(Eigen::Vector3d{0.8164966, 0.0,
    0.5773503}, 120.0);
    Eigen::Matrix3d rot_fa = rotation_matrix_from_frame_axes(Eigen::Vector3d{0.5, 0.5, 0.707107},
    Eigen::Vector3d{-0.5, -0.5, 0.707107}, Eigen::Vector3d{0.707107, -0.707107, 0.0});
    std::cout << "Rotation matrix from Euler: " << std::endl;
    std::cout << rot << std::endl << std::endl;
    std::cout << "Rotation matrix from axis-angle pair: " << std::endl;
    std::cout << rot_aa << std::endl << std::endl;
    std::cout << "Rotation matrix from frame axes: " << std::endl;
    std::cout << rot_fa << std::endl << std::endl;
}
// could remove std:: when using nameplace std
// Task 3a.
//generated by chatgpt using Equation (3.62) Page 87 MR pre-print 2019

Eigen::Matrix4d transformation_matrix(const Eigen::Matrix3d &R, const Eigen::Vector3d &p)
{
    Eigen::Matrix4d T = Eigen::Matrix4d::Identity(); // start as 4x4 identity

    // Top-left 3x3 block is the rotation matrix
    T.block<3,3>(0,0) = R; //picks out a 3x3 matrix from T which is a 4x4 matrix where the bottom
    //is zero and the most right coloum is the postion vector p.

    // Top-right 3x1 block is the translation vector
    T.block<3,1>(0,3) = p;

    return T;
}
//task 3.b
//generated by chatgpt using T_ab*v_b=v_a from page 91 and Equation (3.65) page 88 MR pre-print 2019

void transformation_matrix_test()
{
    Eigen::Matrix3d r = rotation_matrix_from_euler_zyx(Eigen::Vector3d{45, -45.0, 90.0});
    Eigen::Vector3d v{1.0, -2.0, 3.0};
    cout << "transformation_matrix: " << endl;
    cout << transformation_matrix(r, v) << endl;
}
//Task 3.c
//generated by chatgpt
void transform_vector()
{
    // Euler ZYX angles (degrees)
    Eigen::Vector3d e(60.0, 45.0, 0.0);

    // Translation along z-axis
    Eigen::Vector3d p(0.0, 0.0, 10.0);

    // Rotation matrix
    Eigen::Matrix3d R = rotation_matrix_from_euler_zyx(e);

    // Homogeneous transformation matrix
    Eigen::Matrix4d T = transformation_matrix(R, p);

    // Vector in {a} (homogeneous coordinates)
    Eigen::Vector4d va_h;
    va_h << 2.5, 3.0, -10.0, 1.0;

    // Transform to world frame
    Eigen::Vector4d vw_h = T * va_h;

    // Extract top 3 components
    Eigen::Vector3d vw = vw_h.head<3>();

    cout << "Vector in world frame {w}: \n" << vw << endl;
}

int main()
{
//Task 1a and b test.
    skew_symmetric_test();
//task 2 g) Copies test from task description
    rotation_matrix_test();
    //Test gives out wrong numbers for very small numbers because of float values being "noicy".
    //this means that there most likely numbers or "noice" in the cache effecting very small numbers.
    // Thus we can say that the test ist successful we have the expected rotation matrix
    transformation_matrix_test();
    // still get the error for small numbers but it looks correct otherwise.
    //Task 3.c
    transform_vector();
 return 0;
}
